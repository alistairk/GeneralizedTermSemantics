package GenTS.Distance;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Date;
import java.util.TreeMap;

/**
 * This class is used for loading a matrix and performing cosine similarity between
 * pairs of words represented in the matrix. It can be used to find distances between
 * a pair of words, or to get an ordered list of related words. It takes two arguments
 * one being the path to the list of words, the "rlabel" file and the second being to
 * the row matrix file "matrix_crs.mat". It will work with re-weighted matrices,
 * "matrix_crs.mat.TYPE_POS" generated by WeightFeaturesUnsupervised.
 * 
 * To run:
 * java LoadForCosine <path to rlabel file> <path to matrix_crs.mat file>
 * 
 * This program will simply execute some tests from its main method, but more likely you
 * will want to create another class that calls it. See the main method for some examples.
 * 
 * A new LoadForCosine is created: LoadForCosine loader = new LoadForCosine(args[0], args[1]);
 * There are two main methods of using this class, the first is to find the cosine similarity
 * between two words, e.g.: loader.cosine("cat", "dog");
 * 
 * When measuring cosine similarity between two words, if the first is not found it returns
 * -1, if the second word is not found it returns -2.
 * 
 * The second main function of this class is to generate a list of the closest related words
 * to a given word. This can be run as follows: loader.getClosestCosine("monkey", 100);
 * 
 * This will return an array of type WordDist containing the 100 closest related words to 
 * "monkey" from the matrix. This function runs much slower than cosine similarity as it
 * requires the distance between the word, "monkey", and all other words in the matrix to
 * be calculated.
 * 
 * An easy method for printing out an array of type wordDist is provided as well:
 * loader.printWordArray(loader.getClosestCosine("monkey", 100));
 * 
 * This method will print out lists of neighbouring words in the following format:
 * beet (0.44928065), electrodynamics (0.34833947), sleeve (0.30810094), trivium (0.30095348) ...
 * where the cosine similarity to "monkey" is indicated in brackets.
 * 
 * @author akennedy
 *
 */
public class LoadForRelatedness {
	//TreeMap maps words to their row number in the matrix
	private TreeMap<String,Integer> words;
	//holds the denominator scores for each word, calculated at load time.
	private float[] wordVectorValue;
	// holds the matrix, every word is made up of a TreeMap of column, value pairs.
	private ArrayList<TreeMap<Integer,Float>> matrix;
	
	/**
	 * This runs several test cases for this class.
	 * 
	 * @param args
	 */
	public static void main(String args[]){
		if(args.length != 2){
			System.out.println("To Run Program: java LoadForCosine <path to rlabel file> <path to matrix_crs.mat file>");
			return;
		}
		
		LoadForRelatedness loader = new LoadForRelatedness(args[0], args[1]);
		
		System.out.println("Distance between \"cat\" and \"cat\": " + loader.distance("cat", "cat"));
		System.out.println("Distance between \"cat\" and \"dog\": " + loader.distance("cat", "dog"));
		System.out.println("Distance between \"dog\" and \"cat\": " + loader.distance("dog", "cat"));
		System.out.println("Distance between \"laugh\" and \"fight\": " + loader.distance("laugh", "fight"));
		System.out.println("Distance between \"fight\" and \"laugh\": " + loader.distance("fight", "laugh"));
		System.out.println("Distance between \"fight\" and \"asdf\": " + loader.distance("fight", "asdf"));
		long start = new Date().getTime();
		System.out.println();
		System.out.println("List of the top 100 closest words to \"monkey\":");
		loader.printWordArray(loader.getClosestWords("monkey", 100));
		long end = new Date().getTime();
		long difference = end-start;
		System.out.println("time to find neighbours of \"monkey\": " + difference);
	}
	
	/**
	 * This constructor takes two arguments, the first being a list of words found
	 * in the matrix, the "rlabel" file. The second is the path to the sparse row
	 * matrix "matrix_crs.mat". This calls functions to load the words and the
	 * matrix.
	 * 
	 * @param wordsFile
	 * @param matrixFile
	 */
	public LoadForRelatedness(String wordsFile, String matrixFile){
		loadWords(wordsFile);
		loadMatrix(matrixFile);
	}

	/**
	 * Loads the sparse matrix rows file "matrix_crs.mat". It reads the file
	 * and simultaneously calculates the magnitude of each word vector in the matrix
	 * thus calculating most of the denominator at load time. This slows down the
	 * load time somewhat, but hopefully will save time when running many queries
	 * on the matrix.
	 * 
	 * 
	 * @param file
	 */
	private void loadMatrix(String file) {
		try{
			BufferedReader in = new BufferedReader(new FileReader(file));
			String line = in.readLine();
			String[] parts = line.split(" ");
			wordVectorValue = new float[Integer.parseInt(parts[0])];
			matrix = new ArrayList<TreeMap<Integer,Float>>();
			int count = 0;
			while((line = in.readLine()) != null){
				String[] values = line.split(" ");
				TreeMap<Integer,Float> ht = new TreeMap<Integer,Float>();
				double wordScore = 0;
				for(int i = 1; i < values.length; i+=2){
					int id = Integer.parseInt(values[i-1]);
					float magnitued = Float.parseFloat(values[i]);
					ht.put(id, magnitued);
					wordScore += magnitued * magnitued;
				}
				matrix.add(ht);
				wordVectorValue[count] = (float)Math.sqrt(wordScore);
				
				count++;
				if(count % 10000 == 0){
					System.err.println(count);
				}
			}
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}

	/**
	 * Loads from the "rlabel" file and stores every word in the words TreeMap
	 * connecting each word to its corresponding line in the array.
	 * 
	 * @param file
	 */
	private void loadWords(String file) {
		words = new TreeMap<String,Integer>();
		try{
			BufferedReader in = new BufferedReader(new FileReader(file));
			String line;
			int count = 0;
			while((line = in.readLine()) != null){
				//System.out.println(line);
				words.put(line, count);
				count++;
			}
		}
		catch(Exception e){
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Performs cosine similarity between two words. If the first word is missing
	 * it returns -1, if the second word is missing it returns -2, otherwise it
	 * returns the similarity between 0..1.
	 * 
	 * @param word1
	 * @param word2
	 * @return
	 */
	public float distance(String word1, String word2){
		int id1 = 0;
		int id2 = 0;
		try{
			id1 = words.get(word1);
		} catch(Exception e){
			return -1;
		}
		try{
			id2 = words.get(word2);
		} catch(Exception e){
			return -2;
		}
		//get TreeMap vectors for both the words and calculate the denominator
		TreeMap<Integer, Float> row1 = matrix.get(id1);
		TreeMap<Integer, Float> row2 = matrix.get(id2);
		float denominator = wordVectorValue[id1] * wordVectorValue[id2];
		//calculate and return cosine similarity
		return cosineValue(row1, row2, denominator);
	}
	
	/**
	 * Takes row1 and row2 as TreeMaps and the pre-calculated denominator. The 
	 * shorter of these two rows is selected and iterated through. Common features 
	 * between the two rows are identified and the numerator is calculated. Finally
	 * it returns the cosine similarity.
	 * 
	 * @param row1
	 * @param row2
	 * @param denominator
	 * @return
	 */
	private float cosineValue(TreeMap<Integer, Float> row1, TreeMap<Integer, Float> row2, float denominator){
		float numerator = 0;
		if(row1.keySet().size() <= row2.keySet().size()){
			for(int key : row1.keySet()){
				if(row2.containsKey(key)){
					numerator += row1.get(key) * row2.get(key);
				}
			}
		}
		else{
			for(int key : row2.keySet()){
				if(row1.containsKey(key)){
					numerator += row1.get(key) * row2.get(key);
				}
			}
		}
		
		return numerator/denominator;
	}
	
	/**
	 * This method calculates a list of the closest related words to a given word.
	 * The first argument is a word and the second argument is the number of nearest
	 * neighbours that are desired. If the word is not found null is returned.
	 * Otherwise it goes through the set of words and calculates the
	 * distance between the word passed as an argument and all other
	 * words in the matrix using the cosineValue method. 
	 * 
	 * @param word
	 * @param topX
	 * @return
	 */
	public WordDist[] getClosestWords(String word, int topX){
		//declare the array to be returned.
		WordDist[] toReturn = new WordDist[topX];
		for(int i = 0; i < topX; i++){
			WordDist d = new WordDist("", 0);
			toReturn[i] = d;
		}
		int id1 = 0;
		try{
			id1 = words.get(word);
		}
		catch(Exception e){
			return null;
		}
		
		TreeMap<Integer, Float> row1 = matrix.get(id1);
		float denominator1 = wordVectorValue[id1];
		//go through each word in the matrix
		for(String key : words.keySet()){
			int id2 = words.get(key);
				if(id1 != id2){
				TreeMap<Integer, Float> row2 = matrix.get(id2);
				float denominator = denominator1 * wordVectorValue[id2];
				
				float cosine =  cosineValue(row1, row2, denominator);
				WordDist w = new WordDist(key,cosine);
				//insert the new WordDist into the array to return
				insert(toReturn, w);
			}
		}
		
		return toReturn;
	}

	/**
	 * Inserts takes an array of type WordDist and a WordDist to be inserted into
	 * the list. The WordDist w is placed in order into the array.
	 * 
	 * @param toReturn
	 * @param w
	 */
	private void insert(WordDist[] toReturn, WordDist w) {
		int index = toReturn.length-1;
		while(index >= 0 && toReturn[index].getSimilarity() < w.getSimilarity()){
			if(index < toReturn.length-1){
				toReturn[index+1] = toReturn[index];
			}
			index--;
		}
		if(index < toReturn.length-1){
			toReturn[index+1] = w;
			//printWordArray(toReturn);
		}
		
	}
	
	/**
	 * Prints out the content of an array of type WordDist. It is
	 * synchronized so that multiple threads can be called at
	 * once.
	 * 
	 * @param words
	 */
	public synchronized void printWordArray(WordDist[] words){
		if(words != null){
			for(int i = 0; i < words.length-1; i++){
				System.out.print(words[i] + ", ");
			}
			System.out.println(words[words.length-1]);
		}
		else{
			System.out.println();
		}
	}

	
	/**
	 * Prints out the content of an array of type WordDist with the
	 * target word as well. It is synchronized so that multiple threads
	 * can be called at once.
	 * 
	 * @param words
	 */
	public synchronized void printWordArray(String target, WordDist[] words){
		System.out.print(target + " : ");
		if(words != null){
			for(int i = 0; i < words.length-1; i++){
				System.out.print(words[i] + ", ");
			}
			System.out.println(words[words.length-1]);
		}
		else{
			System.out.println();
		}
	}

}
